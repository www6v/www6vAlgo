<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>AREAL on LLM 算法</title>
    <link>https://www6v.github.io/www6vAlgo/docs/Agent/infra/AREAL/</link>
    <description>Recent content in AREAL on LLM 算法</description>
    <generator>Hugo</generator>
    <language>en</language>
    <atom:link href="https://www6v.github.io/www6vAlgo/docs/Agent/infra/AREAL/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>AREAL partial-rollout</title>
      <link>https://www6v.github.io/www6vAlgo/docs/Agent/infra/AREAL/AREAL-partial-rollout/areal_offpolicyness_analysis/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://www6v.github.io/www6vAlgo/docs/Agent/infra/AREAL/AREAL-partial-rollout/areal_offpolicyness_analysis/</guid>
      <description>&lt;h1 id=&#34;areal-中的-off-policyness-与-partial-rollouts-实现详解&#34;&gt;&#xA;  AReaL 中的 Off-policyness 与 Partial Rollouts 实现详解&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#areal-%e4%b8%ad%e7%9a%84-off-policyness-%e4%b8%8e-partial-rollouts-%e5%ae%9e%e7%8e%b0%e8%af%a6%e8%a7%a3&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;概述&#34;&gt;&#xA;  概述&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a6%82%e8%bf%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;AReaL 框架通过&lt;strong&gt;异步推理和训练分离&lt;/strong&gt;的架构，实现了高效的分布式 RL 训练。在这个过程中，核心挑战是如何处理：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;Off-policyness（策略过时性）&lt;/strong&gt;：推理引擎使用的模型版本可能落后于训练引擎的版本&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Partial Rollouts（部分轨迹）&lt;/strong&gt;：单个生成序列可能跨越多个模型版本&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;本文将深入分析 AReaL 如何通过 &lt;code&gt;StalenessManager&lt;/code&gt;、版本跟踪机制和 &lt;code&gt;WorkflowExecutor&lt;/code&gt; 来管理这些问题。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;1-off-policyness-控制机制&#34;&gt;&#xA;  1. Off-policyness 控制机制&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#1-off-policyness-%e6%8e%a7%e5%88%b6%e6%9c%ba%e5%88%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;11-配置参数&#34;&gt;&#xA;  1.1 配置参数&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#11-%e9%85%8d%e7%bd%ae%e5%8f%82%e6%95%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;AReaL 通过 &lt;code&gt;max_head_offpolicyness&lt;/code&gt; 参数控制允许的最大版本差：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;rollout&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;max_head_offpolicyness&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;# 允许推理版本最多落后训练版本 4 步&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;关键配置说明&lt;/strong&gt;：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;0&lt;/code&gt;：同步 RL（推理和训练完全同步，用于调试）&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;2-8&lt;/code&gt;：典型异步范围（根据模型大小和更新频率调整）&lt;/li&gt;&#xA;&lt;li&gt;更高值：提高吞吐量，但可能降低训练稳定性&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;12-stalenessmanager-核心实现&#34;&gt;&#xA;  1.2 StalenessManager 核心实现&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#12-stalenessmanager-%e6%a0%b8%e5%bf%83%e5%ae%9e%e7%8e%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;&lt;code&gt;StalenessManager&lt;/code&gt; 是控制 off-policyness 的核心组件，位于 &lt;code&gt;areal/core/staleness_manager.py&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;h4 id=&#34;121-容量计算公式&#34;&gt;&#xA;  1.2.1 容量计算公式&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#121-%e5%ae%b9%e9%87%8f%e8%ae%a1%e7%ae%97%e5%85%ac%e5%bc%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;get_capacity&lt;/span&gt;(self) &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; int:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&amp;#34;计算可用的新 rollout 槽位数量&amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;with&lt;/span&gt; self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;lock:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        current_version &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;version_provider&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;get_version()  &lt;span style=&#34;color:#75715e&#34;&gt;# 获取当前训练版本&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# 并发限制容量&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        max_concurrent_rollouts &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; max(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;max_concurrent_rollouts)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        concurrency_capacity &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; max_concurrent_rollouts &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;rollout_stat&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;running&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# 过时性限制容量&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ofp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;max_staleness  &lt;span style=&#34;color:#75715e&#34;&gt;# max_head_offpolicyness&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        sample_cnt &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;rollout_stat&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;accepted &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;rollout_stat&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;running&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        consumer_bs &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; max(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;consumer_batch_size)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        staleness_capacity &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (ofp &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; current_version &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; consumer_bs &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; sample_cnt&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# 返回两者的最小值&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        capacity &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; min(concurrency_capacity, staleness_capacity)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; capacity&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;容量计算逻辑&lt;/strong&gt;：&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
